// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCharge = `-- name: CreateCharge :exec
INSERT INTO charges(id, type, payload, lc_organization_id, status, created_at)
VALUES ($1, $2, $3, $4, $5, NOW())
`

type CreateChargeParams struct {
	ID               string
	Type             string
	Payload          []byte
	LcOrganizationID string
	Status           string
}

func (q *Queries) CreateCharge(ctx context.Context, arg CreateChargeParams) error {
	_, err := q.db.Exec(ctx, createCharge,
		arg.ID,
		arg.Type,
		arg.Payload,
		arg.LcOrganizationID,
		arg.Status,
	)
	return err
}

const createEvent = `-- name: CreateEvent :exec
INSERT INTO billing_events(id, lc_organization_id, type, action, payload, error, created_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW())
`

type CreateEventParams struct {
	ID               string
	LcOrganizationID string
	Type             string
	Action           string
	Payload          []byte
	Error            pgtype.Text
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) error {
	_, err := q.db.Exec(ctx, createEvent,
		arg.ID,
		arg.LcOrganizationID,
		arg.Type,
		arg.Action,
		arg.Payload,
		arg.Error,
	)
	return err
}

const createSubscription = `-- name: CreateSubscription :exec
INSERT INTO subscriptions(id, lc_organization_id, plan_name, charge_id, created_at)
VALUES ($1, $2, $3, $4, NOW())
`

type CreateSubscriptionParams struct {
	ID               string
	LcOrganizationID string
	PlanName         string
	ChargeID         pgtype.Text
}

func (q *Queries) CreateSubscription(ctx context.Context, arg CreateSubscriptionParams) error {
	_, err := q.db.Exec(ctx, createSubscription,
		arg.ID,
		arg.LcOrganizationID,
		arg.PlanName,
		arg.ChargeID,
	)
	return err
}

const deleteCharge = `-- name: DeleteCharge :exec
UPDATE charges
SET deleted_at = now()
WHERE id = $1
`

func (q *Queries) DeleteCharge(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteCharge, id)
	return err
}

const deleteSubscription = `-- name: DeleteSubscription :exec
UPDATE subscriptions
SET deleted_at = NOW()
WHERE id = $1 and lc_organization_id = $2
`

type DeleteSubscriptionParams struct {
	ID               string
	LcOrganizationID string
}

func (q *Queries) DeleteSubscription(ctx context.Context, arg DeleteSubscriptionParams) error {
	_, err := q.db.Exec(ctx, deleteSubscription, arg.ID, arg.LcOrganizationID)
	return err
}

const deleteSubscriptionByChargeID = `-- name: DeleteSubscriptionByChargeID :exec
UPDATE subscriptions
SET deleted_at = now()
WHERE charge_id = $1
AND lc_organization_id = $2
`

type DeleteSubscriptionByChargeIDParams struct {
	ChargeID         pgtype.Text
	LcOrganizationID string
}

func (q *Queries) DeleteSubscriptionByChargeID(ctx context.Context, arg DeleteSubscriptionByChargeIDParams) error {
	_, err := q.db.Exec(ctx, deleteSubscriptionByChargeID, arg.ChargeID, arg.LcOrganizationID)
	return err
}

const getChargeByID = `-- name: GetChargeByID :one
SELECT id, lc_organization_id, type, payload, created_at, deleted_at, status
FROM charges
WHERE id = $1
AND deleted_at IS NULL
`

func (q *Queries) GetChargeByID(ctx context.Context, id string) (Charge, error) {
	row := q.db.QueryRow(ctx, getChargeByID, id)
	var i Charge
	err := row.Scan(
		&i.ID,
		&i.LcOrganizationID,
		&i.Type,
		&i.Payload,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Status,
	)
	return i, err
}

const getChargeByOrganizationID = `-- name: GetChargeByOrganizationID :one
SELECT id, lc_organization_id, type, payload, created_at, deleted_at, status
FROM charges
WHERE lc_organization_id = $1
AND deleted_at IS NULL
`

func (q *Queries) GetChargeByOrganizationID(ctx context.Context, lcOrganizationID string) (Charge, error) {
	row := q.db.QueryRow(ctx, getChargeByOrganizationID, lcOrganizationID)
	var i Charge
	err := row.Scan(
		&i.ID,
		&i.LcOrganizationID,
		&i.Type,
		&i.Payload,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.Status,
	)
	return i, err
}

const getChargesByOrganizationID = `-- name: GetChargesByOrganizationID :many
SELECT id, lc_organization_id, type, payload, created_at, deleted_at, status
FROM charges
WHERE lc_organization_id = $1
`

func (q *Queries) GetChargesByOrganizationID(ctx context.Context, lcOrganizationID string) ([]Charge, error) {
	rows, err := q.db.Query(ctx, getChargesByOrganizationID, lcOrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Charge
	for rows.Next() {
		var i Charge
		if err := rows.Scan(
			&i.ID,
			&i.LcOrganizationID,
			&i.Type,
			&i.Payload,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getChargesByStatuses = `-- name: GetChargesByStatuses :many
SELECT id, lc_organization_id, type, payload, created_at, deleted_at, status
FROM charges
WHERE status = ANY($1::text[])
`

func (q *Queries) GetChargesByStatuses(ctx context.Context, dollar_1 []string) ([]Charge, error) {
	rows, err := q.db.Query(ctx, getChargesByStatuses, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Charge
	for rows.Next() {
		var i Charge
		if err := rows.Scan(
			&i.ID,
			&i.LcOrganizationID,
			&i.Type,
			&i.Payload,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSubscriptionByChargeID = `-- name: GetSubscriptionByChargeID :one
SELECT id, lc_organization_id, plan_name, charge_id, created_at, deleted_at
FROM active_subscriptions
WHERE charge_id = $1
`

func (q *Queries) GetSubscriptionByChargeID(ctx context.Context, chargeID pgtype.Text) (ActiveSubscription, error) {
	row := q.db.QueryRow(ctx, getSubscriptionByChargeID, chargeID)
	var i ActiveSubscription
	err := row.Scan(
		&i.ID,
		&i.LcOrganizationID,
		&i.PlanName,
		&i.ChargeID,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getSubscriptionsByOrganizationID = `-- name: GetSubscriptionsByOrganizationID :many
SELECT s.id, s.lc_organization_id, plan_name, charge_id, s.created_at, s.deleted_at, c.id, c.lc_organization_id, type, payload, c.created_at, c.deleted_at, status
FROM subscriptions s
LEFT JOIN charges c on s.charge_id = c.id
WHERE s.lc_organization_id = $1
ORDER BY s.created_at DESC
`

type GetSubscriptionsByOrganizationIDRow struct {
	ID                 string
	LcOrganizationID   string
	PlanName           string
	ChargeID           pgtype.Text
	CreatedAt          pgtype.Timestamptz
	DeletedAt          pgtype.Timestamptz
	ID_2               pgtype.Text
	LcOrganizationID_2 pgtype.Text
	Type               pgtype.Text
	Payload            []byte
	CreatedAt_2        pgtype.Timestamptz
	DeletedAt_2        pgtype.Timestamptz
	Status             pgtype.Text
}

func (q *Queries) GetSubscriptionsByOrganizationID(ctx context.Context, lcOrganizationID string) ([]GetSubscriptionsByOrganizationIDRow, error) {
	rows, err := q.db.Query(ctx, getSubscriptionsByOrganizationID, lcOrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSubscriptionsByOrganizationIDRow
	for rows.Next() {
		var i GetSubscriptionsByOrganizationIDRow
		if err := rows.Scan(
			&i.ID,
			&i.LcOrganizationID,
			&i.PlanName,
			&i.ChargeID,
			&i.CreatedAt,
			&i.DeletedAt,
			&i.ID_2,
			&i.LcOrganizationID_2,
			&i.Type,
			&i.Payload,
			&i.CreatedAt_2,
			&i.DeletedAt_2,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCharge = `-- name: UpdateCharge :exec
UPDATE charges
SET payload = $2
WHERE id = $1
AND deleted_at IS NULL
`

type UpdateChargeParams struct {
	ID      string
	Payload []byte
}

func (q *Queries) UpdateCharge(ctx context.Context, arg UpdateChargeParams) error {
	_, err := q.db.Exec(ctx, updateCharge, arg.ID, arg.Payload)
	return err
}

const updateChargeStatus = `-- name: UpdateChargeStatus :exec
UPDATE charges
SET status = $2
WHERE id = $1
`

type UpdateChargeStatusParams struct {
	ID     string
	Status string
}

func (q *Queries) UpdateChargeStatus(ctx context.Context, arg UpdateChargeStatusParams) error {
	_, err := q.db.Exec(ctx, updateChargeStatus, arg.ID, arg.Status)
	return err
}
