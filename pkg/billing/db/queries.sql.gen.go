// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCharge = `-- name: CreateCharge :exec
INSERT INTO charges(id, type, payload, created_at, deleted_at)
VALUES ($1, $2, $3, NOW(), $4)
`

type CreateChargeParams struct {
	ID        string
	Type      string
	Payload   []byte
	DeletedAt pgtype.Timestamptz
}

func (q *Queries) CreateCharge(ctx context.Context, arg CreateChargeParams) error {
	_, err := q.db.Exec(ctx, createCharge,
		arg.ID,
		arg.Type,
		arg.Payload,
		arg.DeletedAt,
	)
	return err
}

const createInstallationCharge = `-- name: CreateInstallationCharge :exec
INSERT INTO installation_charges(installation_id, charge_id)
VALUES ($1, $2) ON CONFLICT (installation_id) DO UPDATE SET charge_id = $2
`

type CreateInstallationChargeParams struct {
	InstallationID string
	ChargeID       pgtype.Text
}

func (q *Queries) CreateInstallationCharge(ctx context.Context, arg CreateInstallationChargeParams) error {
	_, err := q.db.Exec(ctx, createInstallationCharge, arg.InstallationID, arg.ChargeID)
	return err
}

const deleteChargeForInstallationID = `-- name: DeleteChargeForInstallationID :exec
UPDATE charges
SET deleted_at = now()
WHERE id = (SELECT charge_id from installation_charges WHERE installation_id = $1)
`

func (q *Queries) DeleteChargeForInstallationID(ctx context.Context, installationID string) error {
	_, err := q.db.Exec(ctx, deleteChargeForInstallationID, installationID)
	return err
}

const getChargeByID = `-- name: GetChargeByID :one
SELECT id, type, payload, created_at, deleted_at, installation_id, charge_id
FROM charges c LEFT JOIN installation_charges ic on c.id = ic.charge_id
WHERE id = $1
`

type GetChargeByIDRow struct {
	ID             string
	Type           string
	Payload        []byte
	CreatedAt      pgtype.Timestamptz
	DeletedAt      pgtype.Timestamptz
	InstallationID pgtype.Text
	ChargeID       pgtype.Text
}

func (q *Queries) GetChargeByID(ctx context.Context, id string) (GetChargeByIDRow, error) {
	row := q.db.QueryRow(ctx, getChargeByID, id)
	var i GetChargeByIDRow
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Payload,
		&i.CreatedAt,
		&i.DeletedAt,
		&i.InstallationID,
		&i.ChargeID,
	)
	return i, err
}

const getChargeByInstallationID = `-- name: GetChargeByInstallationID :one
SELECT installation_id, charge_id, id, type, payload, created_at, deleted_at
FROM installation_charges ic LEFT JOIN charges c on c.id = ic.charge_id
WHERE installation_id = $1
`

type GetChargeByInstallationIDRow struct {
	InstallationID string
	ChargeID       pgtype.Text
	ID             pgtype.Text
	Type           pgtype.Text
	Payload        []byte
	CreatedAt      pgtype.Timestamptz
	DeletedAt      pgtype.Timestamptz
}

func (q *Queries) GetChargeByInstallationID(ctx context.Context, installationID string) (GetChargeByInstallationIDRow, error) {
	row := q.db.QueryRow(ctx, getChargeByInstallationID, installationID)
	var i GetChargeByInstallationIDRow
	err := row.Scan(
		&i.InstallationID,
		&i.ChargeID,
		&i.ID,
		&i.Type,
		&i.Payload,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const updateCharge = `-- name: UpdateCharge :exec
UPDATE charges
SET payload = $2
WHERE id = $1
`

type UpdateChargeParams struct {
	ID      string
	Payload []byte
}

func (q *Queries) UpdateCharge(ctx context.Context, arg UpdateChargeParams) error {
	_, err := q.db.Exec(ctx, updateCharge, arg.ID, arg.Payload)
	return err
}
