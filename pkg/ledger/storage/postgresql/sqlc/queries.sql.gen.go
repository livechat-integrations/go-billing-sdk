// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEvent = `-- name: CreateEvent :exec
INSERT INTO ledger_events(id, lc_organization_id, type, action, payload, error, created_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW())
`

type CreateEventParams struct {
	ID               string
	LcOrganizationID string
	Type             string
	Action           string
	Payload          []byte
	Error            pgtype.Text
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) error {
	_, err := q.db.Exec(ctx, createEvent,
		arg.ID,
		arg.LcOrganizationID,
		arg.Type,
		arg.Action,
		arg.Payload,
		arg.Error,
	)
	return err
}

const createLedgerOperation = `-- name: CreateLedgerOperation :exec
INSERT INTO ledger_ledger(id, amount, lc_organization_id, payload, created_at)
VALUES ($1, $2, $3, $4, NOW())
`

type CreateLedgerOperationParams struct {
	ID               string
	Amount           pgtype.Numeric
	LcOrganizationID string
	Payload          []byte
}

func (q *Queries) CreateLedgerOperation(ctx context.Context, arg CreateLedgerOperationParams) error {
	_, err := q.db.Exec(ctx, createLedgerOperation,
		arg.ID,
		arg.Amount,
		arg.LcOrganizationID,
		arg.Payload,
	)
	return err
}

const getDirectTopUpsWithoutOperations = `-- name: GetDirectTopUpsWithoutOperations :many
SELECT tups.id, tups.amount, tups.lc_organization_id, tups.type, tups.status, tups.lc_charge, tups.confirmation_url, tups.current_topped_up_at, tups.next_top_up_at, tups.created_at, tups.updated_at
FROM ledger_top_ups tups
LEFT JOIN ledger_ledger lgr ON tups.id = lgr.id AND tups.lc_organization_id = lgr.lc_organization_id
WHERE tups.type = 'direct'
    AND tups.status = 'success'
    AND lgr.id IS NULL
LIMIT 100
`

func (q *Queries) GetDirectTopUpsWithoutOperations(ctx context.Context) ([]LedgerTopUp, error) {
	rows, err := q.db.Query(ctx, getDirectTopUpsWithoutOperations)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LedgerTopUp
	for rows.Next() {
		var i LedgerTopUp
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.LcOrganizationID,
			&i.Type,
			&i.Status,
			&i.LcCharge,
			&i.ConfirmationUrl,
			&i.CurrentToppedUpAt,
			&i.NextTopUpAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLedgerOperation = `-- name: GetLedgerOperation :one
SELECT id, amount, lc_organization_id, payload, created_at
FROM ledger_ledger
WHERE lc_organization_id = $1
AND id = $2
ORDER BY created_at DESC
`

type GetLedgerOperationParams struct {
	LcOrganizationID string
	ID               string
}

func (q *Queries) GetLedgerOperation(ctx context.Context, arg GetLedgerOperationParams) (LedgerLedger, error) {
	row := q.db.QueryRow(ctx, getLedgerOperation, arg.LcOrganizationID, arg.ID)
	var i LedgerLedger
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.LcOrganizationID,
		&i.Payload,
		&i.CreatedAt,
	)
	return i, err
}

const getLedgerOperationsByOrganizationID = `-- name: GetLedgerOperationsByOrganizationID :many
SELECT id, amount, lc_organization_id, payload, created_at
FROM ledger_ledger
WHERE lc_organization_id = $1
ORDER BY created_at DESC
`

func (q *Queries) GetLedgerOperationsByOrganizationID(ctx context.Context, lcOrganizationID string) ([]LedgerLedger, error) {
	rows, err := q.db.Query(ctx, getLedgerOperationsByOrganizationID, lcOrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LedgerLedger
	for rows.Next() {
		var i LedgerLedger
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.LcOrganizationID,
			&i.Payload,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOrganizationBalance = `-- name: GetOrganizationBalance :one
SELECT COALESCE(SUM(amount), 0)::numeric AS amount FROM ledger_ledger WHERE lc_organization_id = $1
`

func (q *Queries) GetOrganizationBalance(ctx context.Context, lcOrganizationID string) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getOrganizationBalance, lcOrganizationID)
	var amount pgtype.Numeric
	err := row.Scan(&amount)
	return amount, err
}

const getRecurrentTopUpsWhereStatusNotIn = `-- name: GetRecurrentTopUpsWhereStatusNotIn :many
SELECT id, amount, lc_organization_id, type, status, lc_charge, confirmation_url, current_topped_up_at, next_top_up_at, created_at, updated_at
FROM ledger_top_ups
WHERE type = 'recurrent'
  AND NOT (status = ANY($1::text[]))
  AND ((next_top_up_at IS NOT NULL AND next_top_up_at <= NOW() AND status = 'active') || status != 'active')
ORDER BY created_at ASC
    LIMIT 200
`

func (q *Queries) GetRecurrentTopUpsWhereStatusNotIn(ctx context.Context, dollar_1 []string) ([]LedgerTopUp, error) {
	rows, err := q.db.Query(ctx, getRecurrentTopUpsWhereStatusNotIn, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LedgerTopUp
	for rows.Next() {
		var i LedgerTopUp
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.LcOrganizationID,
			&i.Type,
			&i.Status,
			&i.LcCharge,
			&i.ConfirmationUrl,
			&i.CurrentToppedUpAt,
			&i.NextTopUpAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopUpByIDAndOrganizationID = `-- name: GetTopUpByIDAndOrganizationID :one
SELECT id, amount, lc_organization_id, type, status, lc_charge, confirmation_url, current_topped_up_at, next_top_up_at, created_at, updated_at
FROM ledger_top_ups
WHERE id = $1
    AND lc_organization_id = $2
`

type GetTopUpByIDAndOrganizationIDParams struct {
	ID               string
	LcOrganizationID string
}

func (q *Queries) GetTopUpByIDAndOrganizationID(ctx context.Context, arg GetTopUpByIDAndOrganizationIDParams) (LedgerTopUp, error) {
	row := q.db.QueryRow(ctx, getTopUpByIDAndOrganizationID, arg.ID, arg.LcOrganizationID)
	var i LedgerTopUp
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.LcOrganizationID,
		&i.Type,
		&i.Status,
		&i.LcCharge,
		&i.ConfirmationUrl,
		&i.CurrentToppedUpAt,
		&i.NextTopUpAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTopUpByIDAndTypeWhereStatusIsNot = `-- name: GetTopUpByIDAndTypeWhereStatusIsNot :one
SELECT id, amount, lc_organization_id, type, status, lc_charge, confirmation_url, current_topped_up_at, next_top_up_at, created_at, updated_at
FROM ledger_top_ups
WHERE id = $1
  AND type = $2
  AND status != $3
ORDER BY created_at DESC
`

type GetTopUpByIDAndTypeWhereStatusIsNotParams struct {
	ID     string
	Type   string
	Status string
}

func (q *Queries) GetTopUpByIDAndTypeWhereStatusIsNot(ctx context.Context, arg GetTopUpByIDAndTypeWhereStatusIsNotParams) (LedgerTopUp, error) {
	row := q.db.QueryRow(ctx, getTopUpByIDAndTypeWhereStatusIsNot, arg.ID, arg.Type, arg.Status)
	var i LedgerTopUp
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.LcOrganizationID,
		&i.Type,
		&i.Status,
		&i.LcCharge,
		&i.ConfirmationUrl,
		&i.CurrentToppedUpAt,
		&i.NextTopUpAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTopUpsByOrganizationID = `-- name: GetTopUpsByOrganizationID :many
SELECT id, amount, lc_organization_id, type, status, lc_charge, confirmation_url, current_topped_up_at, next_top_up_at, created_at, updated_at
FROM ledger_top_ups
WHERE lc_organization_id = $1
`

func (q *Queries) GetTopUpsByOrganizationID(ctx context.Context, lcOrganizationID string) ([]LedgerTopUp, error) {
	rows, err := q.db.Query(ctx, getTopUpsByOrganizationID, lcOrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LedgerTopUp
	for rows.Next() {
		var i LedgerTopUp
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.LcOrganizationID,
			&i.Type,
			&i.Status,
			&i.LcCharge,
			&i.ConfirmationUrl,
			&i.CurrentToppedUpAt,
			&i.NextTopUpAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopUpsByOrganizationIDAndStatus = `-- name: GetTopUpsByOrganizationIDAndStatus :many
SELECT id, amount, lc_organization_id, type, status, lc_charge, confirmation_url, current_topped_up_at, next_top_up_at, created_at, updated_at
FROM ledger_top_ups
WHERE lc_organization_id = $1
  AND status = $2
`

type GetTopUpsByOrganizationIDAndStatusParams struct {
	LcOrganizationID string
	Status           string
}

func (q *Queries) GetTopUpsByOrganizationIDAndStatus(ctx context.Context, arg GetTopUpsByOrganizationIDAndStatusParams) ([]LedgerTopUp, error) {
	rows, err := q.db.Query(ctx, getTopUpsByOrganizationIDAndStatus, arg.LcOrganizationID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LedgerTopUp
	for rows.Next() {
		var i LedgerTopUp
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.LcOrganizationID,
			&i.Type,
			&i.Status,
			&i.LcCharge,
			&i.ConfirmationUrl,
			&i.CurrentToppedUpAt,
			&i.NextTopUpAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopUpsByTypeWhereStatusNotIn = `-- name: GetTopUpsByTypeWhereStatusNotIn :many
SELECT id, amount, lc_organization_id, type, status, lc_charge, confirmation_url, current_topped_up_at, next_top_up_at, created_at, updated_at
FROM ledger_top_ups
WHERE type = $1
  AND NOT (status = ANY($2::text[]))
ORDER BY created_at ASC
    LIMIT 200
`

type GetTopUpsByTypeWhereStatusNotInParams struct {
	Type    string
	Column2 []string
}

func (q *Queries) GetTopUpsByTypeWhereStatusNotIn(ctx context.Context, arg GetTopUpsByTypeWhereStatusNotInParams) ([]LedgerTopUp, error) {
	rows, err := q.db.Query(ctx, getTopUpsByTypeWhereStatusNotIn, arg.Type, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LedgerTopUp
	for rows.Next() {
		var i LedgerTopUp
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.LcOrganizationID,
			&i.Type,
			&i.Status,
			&i.LcCharge,
			&i.ConfirmationUrl,
			&i.CurrentToppedUpAt,
			&i.NextTopUpAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTopUpRequestStatus = `-- name: UpdateTopUpRequestStatus :exec
UPDATE ledger_top_ups
SET status = $1, updated_at = now()
WHERE id = $2
`

type UpdateTopUpRequestStatusParams struct {
	Status string
	ID     string
}

func (q *Queries) UpdateTopUpRequestStatus(ctx context.Context, arg UpdateTopUpRequestStatusParams) error {
	_, err := q.db.Exec(ctx, updateTopUpRequestStatus, arg.Status, arg.ID)
	return err
}

const upsertTopUp = `-- name: UpsertTopUp :one
INSERT INTO ledger_top_ups(id, status, amount, type, lc_organization_id, lc_charge, confirmation_url, current_topped_up_at, next_top_up_at, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW(),NOW())
ON CONFLICT ON CONSTRAINT ledger_top_ups_pkey DO UPDATE SET lc_charge = EXCLUDED.lc_charge, status = EXCLUDED.status, current_topped_up_at = EXCLUDED.current_topped_up_at, next_top_up_at = EXCLUDED.next_top_up_at, updated_at = NOW()
RETURNING id, amount, lc_organization_id, type, status, lc_charge, confirmation_url, current_topped_up_at, next_top_up_at, created_at, updated_at
`

type UpsertTopUpParams struct {
	ID                string
	Status            string
	Amount            pgtype.Numeric
	Type              string
	LcOrganizationID  string
	LcCharge          []byte
	ConfirmationUrl   string
	CurrentToppedUpAt pgtype.Timestamptz
	NextTopUpAt       pgtype.Timestamptz
}

func (q *Queries) UpsertTopUp(ctx context.Context, arg UpsertTopUpParams) (LedgerTopUp, error) {
	row := q.db.QueryRow(ctx, upsertTopUp,
		arg.ID,
		arg.Status,
		arg.Amount,
		arg.Type,
		arg.LcOrganizationID,
		arg.LcCharge,
		arg.ConfirmationUrl,
		arg.CurrentToppedUpAt,
		arg.NextTopUpAt,
	)
	var i LedgerTopUp
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.LcOrganizationID,
		&i.Type,
		&i.Status,
		&i.LcCharge,
		&i.ConfirmationUrl,
		&i.CurrentToppedUpAt,
		&i.NextTopUpAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
