// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCharge = `-- name: CreateCharge :exec
INSERT INTO ledger_charges(id, amount, status, lc_organization_id, created_at, updated_at)
VALUES ($1, $2, $3, $4, NOW(), NOW())
`

type CreateChargeParams struct {
	ID               string
	Amount           pgtype.Numeric
	Status           string
	LcOrganizationID string
}

func (q *Queries) CreateCharge(ctx context.Context, arg CreateChargeParams) error {
	_, err := q.db.Exec(ctx, createCharge,
		arg.ID,
		arg.Amount,
		arg.Status,
		arg.LcOrganizationID,
	)
	return err
}

const createEvent = `-- name: CreateEvent :exec
INSERT INTO ledger_events(id, lc_organization_id, type, action, payload, error, created_at)
VALUES ($1, $2, $3, $4, $5, $6, NOW())
`

type CreateEventParams struct {
	ID               string
	LcOrganizationID string
	Type             string
	Action           string
	Payload          []byte
	Error            pgtype.Text
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) error {
	_, err := q.db.Exec(ctx, createEvent,
		arg.ID,
		arg.LcOrganizationID,
		arg.Type,
		arg.Action,
		arg.Payload,
		arg.Error,
	)
	return err
}

const getOrganizationBalance = `-- name: GetOrganizationBalance :one
SELECT b.amount::numeric FROM (SELECT (
    SELECT COALESCE(SUM(tu.amount), 0)
    FROM ledger_top_ups tu
    WHERE tu.lc_organization_id = $1
      AND (tu.status = $2 OR (tu.status = $3 AND tu.type = $4))
) - (
    SELECT COALESCE(SUM(c.amount), 0)
    FROM ledger_charges c
    WHERE c.lc_organization_id = $1
      AND c.status = $5
) AS amount) AS b
`

type GetOrganizationBalanceParams struct {
	LcOrganizationID string
	Status           string
	Status_2         string
	Type             string
	Status_3         string
}

func (q *Queries) GetOrganizationBalance(ctx context.Context, arg GetOrganizationBalanceParams) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getOrganizationBalance,
		arg.LcOrganizationID,
		arg.Status,
		arg.Status_2,
		arg.Type,
		arg.Status_3,
	)
	var b_amount pgtype.Numeric
	err := row.Scan(&b_amount)
	return b_amount, err
}

const getTopUpByIDAndTypeWhereStatusIsNot = `-- name: GetTopUpByIDAndTypeWhereStatusIsNot :one
SELECT id, amount, lc_organization_id, type, status, lc_charge, confirmation_url, current_topped_up_at, next_top_up_at, created_at, updated_at, unique_at
FROM ledger_top_ups
WHERE id = $1
  AND type = $2
  AND status != $3
ORDER BY unique_at DESC
`

type GetTopUpByIDAndTypeWhereStatusIsNotParams struct {
	ID     string
	Type   string
	Status string
}

func (q *Queries) GetTopUpByIDAndTypeWhereStatusIsNot(ctx context.Context, arg GetTopUpByIDAndTypeWhereStatusIsNotParams) (LedgerTopUp, error) {
	row := q.db.QueryRow(ctx, getTopUpByIDAndTypeWhereStatusIsNot, arg.ID, arg.Type, arg.Status)
	var i LedgerTopUp
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.LcOrganizationID,
		&i.Type,
		&i.Status,
		&i.LcCharge,
		&i.ConfirmationUrl,
		&i.CurrentToppedUpAt,
		&i.NextTopUpAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UniqueAt,
	)
	return i, err
}

const getTopUpsByOrganizationID = `-- name: GetTopUpsByOrganizationID :many
SELECT id, amount, lc_organization_id, type, status, lc_charge, confirmation_url, current_topped_up_at, next_top_up_at, created_at, updated_at, unique_at
FROM ledger_top_ups
WHERE lc_organization_id = $1
`

func (q *Queries) GetTopUpsByOrganizationID(ctx context.Context, lcOrganizationID string) ([]LedgerTopUp, error) {
	rows, err := q.db.Query(ctx, getTopUpsByOrganizationID, lcOrganizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LedgerTopUp
	for rows.Next() {
		var i LedgerTopUp
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.LcOrganizationID,
			&i.Type,
			&i.Status,
			&i.LcCharge,
			&i.ConfirmationUrl,
			&i.CurrentToppedUpAt,
			&i.NextTopUpAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UniqueAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopUpsByOrganizationIDAndStatus = `-- name: GetTopUpsByOrganizationIDAndStatus :many
SELECT id, amount, lc_organization_id, type, status, lc_charge, confirmation_url, current_topped_up_at, next_top_up_at, created_at, updated_at, unique_at
FROM ledger_top_ups
WHERE lc_organization_id = $1
  AND status = $2
`

type GetTopUpsByOrganizationIDAndStatusParams struct {
	LcOrganizationID string
	Status           string
}

func (q *Queries) GetTopUpsByOrganizationIDAndStatus(ctx context.Context, arg GetTopUpsByOrganizationIDAndStatusParams) ([]LedgerTopUp, error) {
	rows, err := q.db.Query(ctx, getTopUpsByOrganizationIDAndStatus, arg.LcOrganizationID, arg.Status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LedgerTopUp
	for rows.Next() {
		var i LedgerTopUp
		if err := rows.Scan(
			&i.ID,
			&i.Amount,
			&i.LcOrganizationID,
			&i.Type,
			&i.Status,
			&i.LcCharge,
			&i.ConfirmationUrl,
			&i.CurrentToppedUpAt,
			&i.NextTopUpAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.UniqueAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const initTopUpRequiredValues = `-- name: InitTopUpRequiredValues :exec
UPDATE ledger_top_ups l
SET current_topped_up_at = $1, next_top_up_at = $2, unique_at = $3
WHERE l.id = $4
  AND l.type = $5
  AND l.status = $6
  AND l.current_topped_up_at IS NULL
`

type InitTopUpRequiredValuesParams struct {
	CurrentToppedUpAt pgtype.Timestamptz
	NextTopUpAt       pgtype.Timestamptz
	UniqueAt          pgtype.Timestamptz
	ID                string
	Type              string
	Status            string
}

func (q *Queries) InitTopUpRequiredValues(ctx context.Context, arg InitTopUpRequiredValuesParams) error {
	_, err := q.db.Exec(ctx, initTopUpRequiredValues,
		arg.CurrentToppedUpAt,
		arg.NextTopUpAt,
		arg.UniqueAt,
		arg.ID,
		arg.Type,
		arg.Status,
	)
	return err
}

const updateChargeStatus = `-- name: UpdateChargeStatus :exec
UPDATE ledger_charges
SET status = $1, updated_at = now()
WHERE id = $2
`

type UpdateChargeStatusParams struct {
	Status string
	ID     string
}

func (q *Queries) UpdateChargeStatus(ctx context.Context, arg UpdateChargeStatusParams) error {
	_, err := q.db.Exec(ctx, updateChargeStatus, arg.Status, arg.ID)
	return err
}

const updateTopUpRequestStatus = `-- name: UpdateTopUpRequestStatus :exec
UPDATE ledger_top_ups
SET status = $1, updated_at = now()
WHERE id = $2
  AND unique_at = COALESCE($3, '1970-01-01 00:00:00+00'::timestamptz)
`

type UpdateTopUpRequestStatusParams struct {
	Status   string
	ID       string
	UniqueAt pgtype.Timestamptz
}

func (q *Queries) UpdateTopUpRequestStatus(ctx context.Context, arg UpdateTopUpRequestStatusParams) error {
	_, err := q.db.Exec(ctx, updateTopUpRequestStatus, arg.Status, arg.ID, arg.UniqueAt)
	return err
}

const upsertTopUp = `-- name: UpsertTopUp :one
INSERT INTO ledger_top_ups(id, status, amount, type, lc_organization_id, lc_charge, confirmation_url, current_topped_up_at, unique_at, next_top_up_at, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, COALESCE($9, '1970-01-01 00:00:00+00'::timestamptz), $10, COALESCE((SELECT lups.created_at FROM ledger_top_ups lups WHERE lups.id = $1::varchar ORDER BY lups.created_at ASC LIMIT 1)::timestamptz, NOW()),NOW())
ON CONFLICT ON CONSTRAINT ledger_top_ups_pkey DO UPDATE SET lc_charge = EXCLUDED.lc_charge, status = EXCLUDED.status, updated_at = NOW()
RETURNING id, amount, lc_organization_id, type, status, lc_charge, confirmation_url, current_topped_up_at, next_top_up_at, created_at, updated_at, unique_at
`

type UpsertTopUpParams struct {
	ID                string
	Status            string
	Amount            pgtype.Numeric
	Type              string
	LcOrganizationID  string
	LcCharge          []byte
	ConfirmationUrl   string
	CurrentToppedUpAt pgtype.Timestamptz
	Column9           interface{}
	NextTopUpAt       pgtype.Timestamptz
}

func (q *Queries) UpsertTopUp(ctx context.Context, arg UpsertTopUpParams) (LedgerTopUp, error) {
	row := q.db.QueryRow(ctx, upsertTopUp,
		arg.ID,
		arg.Status,
		arg.Amount,
		arg.Type,
		arg.LcOrganizationID,
		arg.LcCharge,
		arg.ConfirmationUrl,
		arg.CurrentToppedUpAt,
		arg.Column9,
		arg.NextTopUpAt,
	)
	var i LedgerTopUp
	err := row.Scan(
		&i.ID,
		&i.Amount,
		&i.LcOrganizationID,
		&i.Type,
		&i.Status,
		&i.LcCharge,
		&i.ConfirmationUrl,
		&i.CurrentToppedUpAt,
		&i.NextTopUpAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.UniqueAt,
	)
	return i, err
}
